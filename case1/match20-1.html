<HTML>
<HEAD>
<TITLE>student_1/</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
student_7/<p><PRE>
&gt;&gt;&gt;&gt; file: parallel_bubble_sort.c


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;
#include&lt;sys/time.h&gt;


#define MAX_COUNT 1000000 // Max integers to sort
#define MAX_NUM 100 // Generate numbers between 0 and MAX_NUM
#define MAX_PROCESS  10
#define SHM_SIZE 102400

key_t key = IPC_PRIVATE;
int P;


typedef struct Data
{
	int N;// number of data.
	int pass;// 0: even odd 1:odd even
    int alldone[MAX_PROCESS];//alldone for each child process. -1: exit  0: done  1: to go
    int swaparray[MAX_PROCESS];//number of swap for each child process.
	long numbers[MAX_COUNT];//data array
	
}Data;



void
print_numbers(Data *data){
    printf("in print\n");
	for(int i = 0; i &lt; data-&gt;N; i++){
		printf("%ld ", data-&gt;numbers[i]);
	}
	printf("\n");
}

int
generateRandomData(long *data, int N){
    printf("generate data\n");
	srandom(time(NULL));
	for(int i = 0; i &lt; N; i++){
		data[i] = random() % MAX_NUM;
	}
	return 0;
}

int update_alldone(int *data, int P){
    //printf("in summation\n");
	int result = 0;
	for(int i = 0; i &lt; P; i++){
		result |= data[i];
	}
	return result;
}



int update_swap(int *data, int P){
    //printf("in summation\n");
    int result = 0;
    for(int i = 0; i &lt; P; i++){
        result |= data[i];
    }
    return result;
}

Data* createSHM(int N){
	//Create the shared memory.
	key_t key;
	int shmid;
	Data *data;
    printf("in create\n");

	if((shmid = shmget(key, SHM_SIZE, 0644 | IPC_CREAT)) == -1){
		perror("shmget failed");
		exit(1);
	}
	data = shmat(shmid, (void *)0, 0);
	if(data == (Data*)(-1)){
		perror("shmat");
		exit(1);
	}else{
		//initiateData(data, N);
        data-&gt;N = N;
        data-&gt;pass = 0;
        for(int i=0;i&lt;P;i++)
        {
            data-&gt;alldone[i]=1;
            data-&gt;swaparray[i]=0;
        }
	}
	return data;
}

int
compare_and_swap(long *number, int i, int j, int N)
{
	assert ( i&lt;N );
	assert ( j&lt;N );

	if( number[i] &gt; number[j]) {
		long temp = number[i];
		number[i] = number[j];
		number[j] = temp;
		return 1;
	}

	return 0;
}


void bubble(Data *data, int start, int n, int procid)
{
    //printf("in bubble\n");
	if(start + n &gt; data-&gt;N)
		n = data-&gt;N - start;
	while(data-&gt;alldone[procid] != -1){
		if(data-&gt;alldone[procid]){
			int swap_count = 0;
			int next = start;

			assert (start &lt; data-&gt;N-1); // bug if we start at the end of array

<A NAME="1"></A><FONT color = #00FF00><A HREF="match20-0.html#1" TARGET="0"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_1_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

			if (data-&gt;pass) { // sort odd-even index pairs
				if ( !(next % 2) ) 
					next = next + 1;
			} else  { // sort even-odd index pairs
				if (next % 2) 
					next = next + 1;
			}

			while ( (next+1) &lt; (start+n) ) {
</FONT>				swap_count += compare_and_swap(data-&gt;numbers, next, next+1, data-&gt;N);
				next+=2;
			}
			data-&gt;swaparray[procid] = swap_count;
			data-&gt;alldone[procid] = 0;
		}
	}
}

void
bubble_sort(Data *data, int P)
{
	int last_count, swap_count = data-&gt;N;
	do{
		last_count = swap_count;
		if( !update_alldone(data-&gt;alldone, P) ){
			swap_count = update_swap(data-&gt;swaparray, P);
			data-&gt;pass = 1 - data-&gt;pass;
            for(int i=0;i&lt;P;i++)
            {
                data-&gt;alldone[i]=1;
                data-&gt;swaparray[i]=0;
            }
		}
	} while((swap_count!=0) || (last_count != 0));
    for(int i=0;i&lt;P;i++)
    {
        data-&gt;alldone[i]=-1;
    }
    print_numbers(data);
}

void create_process(Data *data)
{   int size = 0;
    
    if ((data-&gt;N)%2) {
        size = data-&gt;N/P;
    } else {
        size = (data-&gt;N/P) + 1;
    }
    for(int i = 0; i &lt; P; i++){
        int pid = fork();
        if(pid &lt; 0){
            perror("fork");
            exit(1);
        }
        else if(pid == 0){
            fprintf(stderr, "This is %dth child process, my pid is %d.\n\n", i,getpid());
            if(i==0)
            {
                bubble(data, 0,size, i);
            }
            else if(i== P-1)
            {
                bubble(data, i*(size-1), data-&gt;N - (i * (size - 1)), i);
            }
            else
            {
                bubble(data, i*(size-1), size, i);
            }
            
            exit(0);
        }
        else if(pid &gt; 0){
            fprintf(stderr, "This is parent process, my pid is %d.\n\n", getpid());
        }
    }
    
}

int main(int argc, char* argv[]){
    if(argc != 3){
        fprintf(stderr, "Usage: %s N P\n", argv[0]);
        return 1;
    }
<A NAME="0"></A><FONT color = #FF0000><A HREF="match20-0.html#0" TARGET="0"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_0_6.gif" ALT="other" BORDER="0" ALIGN=left></A>

    int N = strtol(argv[1], (char **)NULL, 10);
     P = strtol(argv[2], (char **)NULL, 10);
    if( (N &lt; 2) || (N &gt; MAX_COUNT) ) {
        fprintf(stderr, "Invalid N. N should be between 2 and %d.\n", MAX_COUNT);
        return 2;
    }
    if( (P &lt; 2) || (P &gt; MAX_PROCESS) ) {
        fprintf(stderr, "Invalid P. P should be between 2 and %d.\n", MAX_PROCESS);
        return 3;
</FONT>    }
    printf("in main\n");
    
    Data *data = createSHM(N);
    generateRandomData(data-&gt;numbers, data-&gt;N);
    print_numbers(data);
   struct timeval begin, end;
   gettimeofday(&begin, NULL);
    create_process(data);
    bubble_sort(data, P);
    gettimeofday(&end, NULL);
    double timeelapsed = (end.tv_sec - begin.tv_sec) +
          ((end.tv_usec - begin.tv_usec)/1000000.0);
    printf("Time taken by parallel even odd bubble sort is : %.3f seconds\n", timeelapsed);
    shmdt(data);

    return 0;
}



</PRE>
</PRE>
</BODY>
</HTML>
