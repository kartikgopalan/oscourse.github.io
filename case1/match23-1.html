<HTML>
<HEAD>
<TITLE>student_1/</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
student_4/<p><PRE>
&gt;&gt;&gt;&gt; file: parallel_bubble_sort.c


#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;

#define DEBUG

#define MAX_NO_OF_DATA 1000    //maximum number of data elements
#define SHM_SIZE 102400        //size of shared memory 1KB
#define MAX_NO_OF_PROCESS 1000  //maximum number of worker process
#define MAX_VALUE_OF_DATA 1000 //maximum value of each data

typedef struct Data Data;

struct Data
{
    int N;                             // number of data elements
    long data[MAX_NO_OF_DATA];         // array to store data
    int state[MAX_NO_OF_PROCESS];      // state for each child process
    int pass;                          // 0-even 1-odd variable to operate through barrier
    int swap_count[MAX_NO_OF_PROCESS]; // number of swap for each worker process during sort
};

/**
 * Function to generate random numbers for array.
 */
int generate_numbers(long *data, int N)
{
    srandom(time(NULL));
    for (int i = 0; i &lt; N; i++)
    {
        data[i] = random() % MAX_VALUE_OF_DATA;
    }
    return 0;
}

/**
 * Function print the value in array.
 */
void print_numbers(Data *data)
{
    for (int i = 0; i &lt; data-&gt;N; i++)
    {
        printf("%ld ", data-&gt;data[i]);
    }
    printf("\n");
}

/**
 * Function to synchronize all elements in array.
 */
int synchronize(Data *data, int inN)
{
    data-&gt;N = inN;
    data-&gt;pass = 0;
    generate_numbers(data-&gt;data, data-&gt;N);
    for (int i = 0; i &lt; data-&gt;N; i++)
    {
        data-&gt;swap_count[i] = 0;
        data-&gt;state[i] = 1;
    }
    return 0;
}

/**
 * Function to create shared memory.
 * 
 * Using shmget () and shmat (), IPC Create and unique key using ftok () through parent process.
 */
Data *create_shared_memory(int N)
{
    key_t key;
    int shmid;
    Data *data;

    /* make the key */
    if ((key = ftok("parallel_bubble_sort", 'A')) == -1)
    {
        perror("ftok");
        exit(1);
    }

    /* create the shared memory segment */
    if ((shmid = shmget(key, SHM_SIZE, 0644 | IPC_CREAT)) == -1)
    {
        perror("shmget failed");
        exit(1);
    }
    /* attach to the segment to get a pointer to it */
    data = shmat(shmid, (void *)0, 0);
    if (data == (Data *)(-1))
    {
        perror("shmat");
        exit(1);
    }
    else
    {
        synchronize(data, N);
    }
    return data;
}
/**
 * Function to swap the values on their index based on sort.
 */
int compare_and_swap(long *number, int i, int j, int N)
{
    assert(i &lt; N);
    assert(j &lt; N);

    if (number[i] &gt; number[j])
    {
        long temp = number[i];
        number[i] = number[j];
        number[j] = temp;
        return 1;
    }

    return 0;
}
/**
 * Function to process bubble sort.
 * 
 * even-odd pass bubbling from start to start+n
 */
void bubble(Data *data, int start, int n, int worker)
{
    if (start + n &gt; data-&gt;N)
        n = data-&gt;N - start;

    while (data-&gt;state[worker] != -1)
    { // Barrier to handle concurrent worker process.
        if (data-&gt;state[worker])
        {
            int swap_count = 0;
            int next = start;

            assert(start &lt; data-&gt;N - 1); // bug if we start at the end of array

<A NAME="1"></A><FONT color = #00FF00><A HREF="match23-0.html#1" TARGET="0"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_1_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

            if (data-&gt;pass)
            { // sort odd-even index pairs
                if (!(next % 2))
                    next = next + 1;
            }
            else
            { // sort even-odd index pairs
                if (next % 2)
                    next = next + 1;
            }

            while ((next + 1) &lt; (start + n))
</FONT>            {
                swap_count += compare_and_swap(data-&gt;data, next, next + 1, data-&gt;N);
                next += 2;
            }

            data-&gt;swap_count[worker] = swap_count;
            data-&gt;state[worker] = 0;
        }
    }
}

/*
 * Function to perform bubble sort.
 */
void bubble_sort(Data *data)
{
    int a, i = 0;
    while (i &lt; data-&gt;N)
    {
        for (int j = i + 1; j &lt; data-&gt;N; ++j)
        {
            if (data-&gt;data[i] &gt; data-&gt;data[j])
            {
                a = data-&gt;data[i];
                data-&gt;data[i] = data-&gt;data[j];
                data-&gt;data[j] = a;
            }
        }
        ++i;
    }
}

/**
 * Function to handle count of swapped values.
 */
int total_no_of_swap(int *data, int P)
{
    int count = 0;
    for (int i = 0; i &lt; P; i++)
    {
        count += data[i];
    }
    return count;
}

/**
 * Function to perform parallel bubble sort using shared memory and concorrent worker process.
 */
void parallel_bubble_sort(Data *data, int P)
{
    int last_count, i = 0;
    int swap_count = data-&gt;N;

#ifdef DEBUG
    fprintf(stderr, "Elements before sorting:\n");
    print_numbers(data);
#endif

    do
    {
        last_count = swap_count;
        if (!total_no_of_swap(data-&gt;state, P))
        {
            swap_count = total_no_of_swap(data-&gt;swap_count, P); // 0 for single-process sorting
            data-&gt;pass = 1 - data-&gt;pass;
            for (int i = 0; i &lt; P; i++)
            {
                data-&gt;swap_count[i] = 0;
                data-&gt;state[i] = 1;
            }
        }
    } while ((swap_count != 0) || (last_count != 0));
    while (i &lt; P)
    {
        data-&gt;state[i] = 1;
        i++;
    }

#ifdef DEBUG
    fprintf(stderr, "\nElements after sorting:\n");
    bubble_sort(data);
    print_numbers(data);
#endif
}

int main(int argc, char *argv[])
{
    if (argc != 3) // Condition to check the passed number of arguments (N, P)
    {
        fprintf(stderr, "Usage: %s N P\n", argv[0]);
        return 1;
    }

    int N = strtol(argv[1], (char **)NULL, 10);
<A NAME="0"></A><FONT color = #FF0000><A HREF="match23-0.html#0" TARGET="0"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_0_4.gif" ALT="other" BORDER="0" ALIGN=left></A>

    int P = strtol(argv[2], (char **)NULL, 10);

    if ((N &lt; 2) || (N &gt; MAX_NO_OF_DATA))
    {
        fprintf(stderr, "Invalid N. N should be between 2 and %d.\n", MAX_NO_OF_DATA);
        return 2;
    }
    if ((P &lt; 2) || (P &gt; MAX_NO_OF_PROCESS))
    {
        fprintf(stderr, "Invalid P. P should be between 2 and %d.\n", MAX_NO_OF_PROCESS);
        return 3;
</FONT>    }
    fprintf(stderr, "\nCS550-Operating Systems - Assignment-1 gets started....!\n\n");

    Data *data = create_shared_memory(N); // To create shared memory. It contains array elements.

    int range = N / P + 1; // To have worker process with different segments with overlapping.

    for (int i = 0; i &lt; P; i++)
    {
        int pid = fork();
        if (pid &lt; 0)
        {
            perror("fork");
            exit(1);
        }
        else if (pid == 0)
        {
            bubble(data, i * (range - 1), range, i);
            exit(0);
        }
    }

    // using gettimeofday() to check the performance.
    struct timeval starting_time;
    struct timeval ending_time;
    gettimeofday(&starting_time, NULL);

    parallel_bubble_sort(data, P);

    //To print the time for performance check.
    gettimeofday(&ending_time, NULL);
    long int time_taken = (ending_time.tv_sec - starting_time.tv_sec) * 1000000 + ending_time.tv_usec - starting_time.tv_usec;
    fprintf(stderr, "\nTime taken to complete parallel bubble sort is %ld microsecond.\n\n", time_taken);

    /* detach from the segment: */
    if (shmdt(data) == -1)
    {
        perror("shmdt");
        exit(1);
    }

    fprintf(stderr, "CS550-Operating Systems - Assignment-1 gets completed....!\n\n");

    return 0;
}
</PRE>
</PRE>
</BODY>
</HTML>
