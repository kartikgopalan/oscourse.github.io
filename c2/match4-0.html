<HTML>
<HEAD>
<TITLE>student_8/</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
student_8/<p><PRE>
&gt;&gt;&gt;&gt; file: parallel_bubble.c
/* Parallel Bubble Sort
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;unistd.h&gt;

#define MAX_COUNT 100 // Max integers to sort
#define MAX_NUM 100 // Generate numbers between 0 and MAX_NUM
#define MAX_CHILD 30
#define SHM_SIZE 1024


// Uncomment the following line to turn on debugging messages
//#define DEBUG


int N; // Number of integers to sort
int P; // Number of children
// generate N random numbers between 0 and MAX_NUM

typedef struct data_struct {
	long number[MAX_COUNT]; // array to sort
	long childrenProcess[MAX_COUNT]; // to track if children are done with the swap
	long checkSwap[MAX_COUNT]; // to keep track of each child swapcount
	int pass;// pass val
} Data;

void generate_numbers(Data * data) {
	int i;
	srand(time(NULL));
	for(i=0; i&lt;N; i++) 
		data-&gt;number[i] = rand()%MAX_NUM;
}

void generateChildren(Data * data) {
	int i;
	pid_t pid;
	int ret;
	int status;
	int sizeOfChild = N/P + 1;
	for (i =0; i&lt; P; i++) {
		if(i == P-1) {
			int diffRange = N - (i*(sizeOfChild-1) + sizeOfChild);
			if (diffRange &gt; 0) {
				sizeOfChild+=diffRange;
			}
		}
		pid = fork();
		if (pid &lt; 0) {
			perror("Error in creating children");
			exit(1);
		}
		else if (pid == 0) {
			printf("Child created with ID %d\n", getpid());
			bubble(data,i*(N/P),sizeOfChild, i);
			exit(0);
		}
		else {
			printf("The is parent. The child is %d\n", pid);
		}
	}
}
<A NAME="4"></A><FONT color = #FF00FF><A HREF="match4-1.html#4" TARGET="1"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_4_3.gif" ALT="other" BORDER="0" ALIGN=left></A>

int ifExitLoop(Data * data) { // check if all swaps are zero, returns 1 in case of zero swap
	int yes = 0;
	for (int i = 0; i &lt; P; i++) {
		if (data-&gt;checkSwap[i] &gt; 0) {
			yes = 1;
			break;
		}
	}
	return yes;
}

void makeSwapStart(Data * data) {
</FONT>	for(int i=0; i&lt;P; i++) 
<A NAME="7"></A><FONT color = #0000FF><A HREF="match4-1.html#7" TARGET="1"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_2_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

		data-&gt;checkSwap[i] = 1;
}	
void makeChildrenStart(Data * data, int val) { // reset childrenProcess value to 0 or 1. means child is ready to start swap
	for(int i=0; i&lt;P; i++) 
		data-&gt;childrenProcess[i] = val;
</FONT>	if (val == 1) {
		data-&gt;pass = 0;
		for(int i=0; i&lt;P; i++) 
			data-&gt;checkSwap[i] = 1;
	}
}

int ifChildrenStart(Data * data) { // checks if all children have 0 value and are ready to start another swap
	int yes = 1;
	for(int i=0; i&lt;P; i++) {
		if(data-&gt;childrenProcess[i] == 1) {
			yes=0;
			break;
		}
	}
	return yes; 
}

int ifChildrenDone(Data * data) { // checks if all children are done with single swap, i.e. childrenProcess[] value should be 1
	int yes = 1;
	for(int i=0; i&lt;P; i++) {
		if(data-&gt;childrenProcess[i] == 0) {
			yes=0;
			break;
		}
	}
	return yes;
}

<A NAME="5"></A><FONT color = #FF0000><A HREF="match4-1.html#5" TARGET="1"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_0_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

void print_numbers(Data * data) {
	int i;
	for(i=0; i&lt;N; i++) 
		printf("%ld ", data-&gt;number[i]);
	printf("\n");
}

int compare_and_swap(Data * data, int i, int j) {
</FONT>#ifdef DEBUG
<A NAME="0"></A><FONT color = #FF0000><A HREF="match4-1.html#0" TARGET="1"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_0_9.gif" ALT="other" BORDER="0" ALIGN=left></A>

	fprintf(stderr,"i %d j %d\n", i, j);
#endif
	assert ( i&lt;N );
	assert ( j&lt;N );
	
	if( data-&gt;number[i] &gt; data-&gt;number[j]) {
		long temp = data-&gt;number[i];
		data-&gt;number[i] = data-&gt;number[j];
		data-&gt;number[j] = temp;
		return 1;
	}
	return 0;
}

// even-odd pass bubbling from start to start+n
void bubble(Data * data, int start, int n, int id) 
{
#ifdef DEBUG
	fprintf(stderr, "start %d n %d pass %d\n", start, n, pass);
</FONT>#endif
	int cnt=0;
	if (start + n &gt; N) {
		n = N - start;
	}
	while (data-&gt;childrenProcess[id] != -1) {
<A NAME="3"></A><FONT color = #00FFFF><A HREF="match4-1.html#3" TARGET="1"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_3_5.gif" ALT="other" BORDER="0" ALIGN=left></A>

		if (data-&gt;childrenProcess[id] == 0) {
			int swap_count = 0;
			int next = start;
			
			assert (start &lt; N-1); // bug if we start at the end of array

			if (data-&gt;pass) { // sort odd-even index pairs
				if ( !(next % 2) ) 
					next = next + 1;
			} else  { // sort even-odd index pairs
				if (next % 2) 
					next = next + 1;
			}

			while ( (next+1) &lt; (start+n) ) {
</FONT>				swap_count += compare_and_swap(data, next, next+1);
				next+=2;
			}
			data-&gt;childrenProcess[id]=1;
			data-&gt;checkSwap[id]=swap_count;
	
			while (ifChildrenStart(data) == 1) {
				break;
			}
		}
	}
}

void parallel_bubble_sort(Data * data) {
	int last_count, swap_count = N;
	int pass = 0;

#ifdef DEBUG
	print_numbers();
#endif
	makeChildrenStart(data,0);
	do {
		last_count = swap_count;
		if(ifChildrenDone(data)) {
			swap_count = ifExitLoop(data);
			pass = data-&gt;pass;
			data-&gt;pass= 1-data-&gt;pass;
			makeChildrenStart(data,0);
		}
<A NAME="6"></A><FONT color = #00FF00><A HREF="match4-1.html#6" TARGET="1"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_1_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

	} while((swap_count!=0) || (last_count != 0) || (pass != 1));
}

int main(int argc, char *argv[]) {

	if( argc != 3) {
		fprintf(stderr, "Usage: %s N\n", argv[0]);
</FONT>		return 1;
	}

<A NAME="1"></A><FONT color = #00FF00><A HREF="match4-1.html#1" TARGET="1"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_1_6.gif" ALT="other" BORDER="0" ALIGN=left></A>

	N = strtol(argv[1], (char **)NULL, 10);
	if( (N &lt; 2) || (N &gt; MAX_COUNT) ) {
		fprintf(stderr, "Invalid N. N should be between 2 and %d.\n", MAX_COUNT);
		return 2;
	}
	P = strtol(argv[2], (char **)NULL, 10);
	if((P &gt;= N) || P &gt; MAX_COUNT) {
		fprintf(stderr, "Invalid P. P should be less than N value (%d), or MAX_CHILD value %d.\n", N, MAX_CHILD);
		return 3;
	}
	
	//Declare variables
	key_t uniq_key; 
	int shmid;
</FONT><A NAME="2"></A><FONT color = #0000FF><A HREF="match4-1.html#2" TARGET="1"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_2_5.gif" ALT="other" BORDER="0" ALIGN=left></A>

	Data * data;
	
	// Generate Unique key
	if((uniq_key = ftok("parallel_sort.txt", 'S')) &lt; 0) {
		perror("Error in creating unique token key");
		exit(1);
	}
	
	//Create shared memory
	if ((shmid = shmget(uniq_key,sizeof(data),0644 | IPC_CREAT)) &lt; 0) {
		perror("Error in creating unique token key");
		exit(1);
	}
	
	//Attach shared memory to Data struct
	data = shmat(shmid, (void *)0, 0);
	
	if (data == (Data *)(-1)) {
		perror("Error in attaching shared memory");
		exit(1);
</FONT>	}
	
	
	for(int i=0; i&lt;N; i++) 
		data-&gt;number[i] = 0;
	
	generate_numbers(data); //Generate numbers and fill the array
	
	printf("Inputted Array: \n");
	print_numbers(data);
	
	makeChildrenStart(data,1); //initialize data members
	generateChildren(data); //Create Children processes

	struct timeval tv1, tv2;
	gettimeofday(&tv1, NULL);
	parallel_bubble_sort(data); //perform sort
	makeChildrenStart(data,-1);
	gettimeofday(&tv2, NULL);
	
	fprintf(stdout, "Sorted sequence is as follows:\n");
	print_numbers(data);
	
	//detach shared memory
	if (shmdt(data) == -1) {
		perror("error in detaching shared memory");
		exit(1);
    }
	
	//delete shared memory
	if(shmctl(shmid, IPC_RMID, NULL) == -1) {
            perror("error in deleting shared memory");
            exit(1);
       }
	
	float time = (tv2.tv_usec - tv1.tv_usec) / 1000000.0 + (tv2.tv_sec - tv1.tv_sec);
	printf("Total time: %f seconds\n", time);
	fprintf(stderr, "Done.\n");

	return 0;
}
</PRE>
</PRE>
</BODY>
</HTML>
