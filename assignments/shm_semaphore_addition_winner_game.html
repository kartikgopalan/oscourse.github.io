<html> 
<HEAD> 
<TITLE>Operating Systems</TITLE> 
  <meta name="robots" content="noindex,nofollow"> 
</HEAD> 
 
<body> 
 
<CENTER> 
<H1>Inter-Process Synchronization and Concurrency</H1> 
</CENTER> 
 
<H2>Summary</H2> 
In this assignment, you will create three versions of a simple multi-process 
game. The three versions differ only in the type of synchronization they 
use: one uses busy-wait, another uses busy-wait with yield, and the third 
uses blocking semaphores. You will also measure the relative performance
of these three versions of your multi-process game.
 
<H2>Objectives</H2> 
<ul> 
	<li> Learn the use of shared memory and semaphores for inter-process communication.
	<li> Measure the effectiveness of process scheduling with synchronization.
</ul> 
 
<H2>Part A: Multi-Process Addition Game Without Locking</H2> 
<P> In this part, you are asked to write a simple program that takes two command-line arguments <b>P</b> and <b>M</b>.<br>
<br>
The main (parent) process does the following:
<ul>
	<li> Creates a shared memory region that hold at least three variables -- two numbers and a winner PID -- plus any additional information you want to keep.
	<li> Writes two positive numbers, 1 and 2, into the two numbers in the shared memory region.
	<li> Forks <B>P</B> child processes.
	<li> Waits for all the children to complete.
	<li> Prints of the larger of the two numbers and the winner PID from the shared memory.
	<li> Exits.
</ul>

Each child process repeats the following steps in a loop until the larger of the two numbers in the shared memory is greater than <b>M</b> (passed via command-line arguments). Don't introduce any locking yet! Wait to do that in Part B below.
<ul>
	<li> If any one of the two numbers in the shared memory is greater than <b>M</b>, then exit.
	<li> Else replace the smaller number in the shared memory with the sum of the two numbers.
	<li> If the result of addition is greater than <b>M</b>, then write this child's process ID into a "winner" variable in the shared memory and exit.
</ul>

Run this program several times for identical values of P and M. Choose large enough M and a reasonably large P. Observe the output. 

Here are some possible race conditions that you may want to look for. These may or may not show up depending on your execution environment.
<ul>
	<li> Does more than one child process ever try to mark itself as winner? 
	<li> Does the sum always update correctly? Could one child process overwrite the sum of another?
	<li> Does the parent always declare the correct process to be the winner?
</ul>

<p><b>Instrumentation:</b>
You can also add additional print statements in the child processes to observe their behavior, but remember that print statements can alter the execution timing of the children by introducing I/O operations (to stdout). Or you could collect necessary data in the child and print it from parent. Think of ways to observe child's behavior without altering it too much.
 
<H2>Part B: Addition Game with Locking</H2> 
Now introduce locking/unlocking around the critical section in each child process. At the beginning of each iteration, acquire the lock. At the end each iteration, release the lock. Something as follows:
<pre>
	while(...) {
		lock
		critical section...
		unlock
	}
</pre>
You have to write three versions of the locking function.
<ol>
	<li>
		One in which the child <b>busy-waits</b> using sem_trywait(). Something as follows:
	<pre>
	while ( sem_trywait(...) &lt 0 ) {
		if( errno == EAGAIN)
			continue;
		else perror("sem_trywait failed:");
	}
	</pre>
	</li>
	<li>
		Another in which you replace the "continue;" statement above with "sched_yield();"
	</li>
	<li>
		And third in which you use a blocking semaphore, using sem_wait(), instead of sem_trywait(). Change the logic of the above code as needed.
	</li>
</ol>
<ul>
	<li><a href=http://www.csc.villanova.edu/~mdamian/threads/posixsem.html>Here's an example of how to use sem_init(), sem_wait(), and sem_post().</a>
</ul>

<H2>Part C: Comparing the three versions of the Addition game</H2> 
<P>In this part, you are asked to write user-level profiling code in order
to compare the relative performance of the three versions of locking mechanisms
you wrote in Part B. Using the gettimeofday() system call, measure and 
plot the following two graphs.
<ul>
	<li>
		Total execution time for the parent process versus number of processes P.
	</li>
	<li>
		The average time to acquire the lock in each child process versus the number of processes P
	</li>
</ul>
<p> Explain the results you obtain in a PDF report that you must include with your submission.

 
<H2>Grading Guidelines</H2> 
<pre> 
	Part A: Multi-Process Addition without locking - 20
		Creation and execution of processes 
		Creation and use of shared memory data region 
 
	Part B: Multi-process Addition with Locking - 50
		Proper semaphore initialization.
		Correct use of locking/unlocking so that only one process is in the critical section at a time 
		Busy-wait locking with "sem_trywait()" and "continue" 
		Busy-wait locking with "sem_trywait()" and "sched_yield()" 
		Busy-wait locking with "sem_wait()" 
 
	Part C: Comparing the Game of Turns - 25
		Correct implementation and collection of profiling statistics 
		Final PDF report with profiling results, graphs and explanations 
 
	Error Handling, README, Makefile and Coding style - 5
		Cleanup of shared memory region, checking for return values/error conditions, etc.
 
	Total = 100
</pre> 
 
<H2>Submission Guidelines</H2> 
<p> Submit all your code and your PDF report as ONE zipped file. Name your directory as "your_username/" and the name the zip file as "your_username.zip". Replace "your_username" with your BU login username (don't use your B number).
 
</body> 
 
</html> 
