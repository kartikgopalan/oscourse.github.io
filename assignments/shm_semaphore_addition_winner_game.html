<html> 
<HEAD> 
<TITLE>Operating Systems</TITLE> 
  <meta name="robots" content="noindex,nofollow"> 
</HEAD> 
 
<body> 
 
<CENTER> 
<H1>Assignment 3<BR> 
Processes, Inter-Process Synchronization, and Concurrency</H1> 
</CENTER> 
 
<H2>Summary</H2> 
In this assignment, you will create three versions of a simple multi-process 
game. The three versions differ only in the type of synchronization they 
use: one uses busy-wait, another uses busy-wait with yield, and the third 
uses blocking semaphores. You will also measure the relative performance
of these three versions of your multi-process game.
 
<H2>Objectives</H2> 
<ul> 
	<li> 
		Learn use of inter-process communication using shared memory and semaphores.
	</li> 
	<li> 
		Learn the basic workings of process scheduling with synchronization.
	</li> 
</ul> 
 
<H2>Part A: Multi-Process Addition Game Without Locking</H2> 
<P> 
In this part, you are asked to write a simple program that takes two command-line arguments <b>P</b> and <b>M</b>.<br>
<br>
The main (parent) process does the following:
<ul>
	<li>
		Creates a shared memory region.
	</li>
	<li>
		Writes two positive integer values, 1 and 2, into the shared memory region.
	</li>
	<li>
		Forks <B>P</B> other child processes.
	</li>
	<li>
		Waits for all the children to complete.
	</li>
	<li>
		Prints of the larger of the two integer values in the shared memory.
	</li>
	<li>
		Reads a "winner" value, which is also located in the shared memory region and prints it out.
	</li>
	<li>
	Exits.
	</li>
</ul>

Each child process repeats the following steps in a loop until the larger of the two numbers in the shared memory is greater than <b>M</b> (passed via command-line arguments). Don't introduce any locking yet! Wait to do that in Part B below.
<ul>
	<li>
		Read the two integers from the shared memory.
	</li>
	<li>
		If any one of them is greater than <b>M</b>, then exit.
	</li>
	<li>
		Else add the two integers.
	</li>
	<li>
		Replace the smaller number in the shared memory with the result of the addition.
	</li>
	<li>
		If the result of addition is greater than <b>M</b>, then write this child's process ID into a "winner" variable in the shared memory region (the one which the parent process will read at the end).
	</li>
</ul>

Run this program several times for identical values of P and M. (Choose large enough P and M). Observe the parent's output. Is it the same every time?
 
<H2>Part B: Addition Game with Locking</H2> 
Now introduce locking/unlocking around the critical section in the child process. At the beginning of each iteration, acquire the lock. At the end each iteration, release the lock. Something as follows:
<pre>
	while(...) {
		lock
		critical section...
		unlock
	}
</pre>
You have to write three versions of the locking function.
<ol>
	<li>
		One in which the child <b>busy-waits</b> using sem_try_wait(). Something as follows:
	<pre>
	while ( sem_try_wait(...) &lt 0 ) {
		if( errno == EAGAIN)
			continue;
		else perror("sem_try_wait failed:");
	}
	</pre>
	</li>
	<li>
		Another in which you replace the "continue;" statement above with "sched_yield();"
	</li>
	<li>
		And third in which you use a blocking semaphore, using sem_wait(), instead of sem_try_wait(). Change the logic of the abover code as needed.
	</li>
</ol>

<H2>Part C: Comparing the three versions of the Addition game</H2> 
<P>In this part, you are asked to write user-level profiling code in order
to compare the relative performance of the three versions of locking mechanisms
you wrote in Part B. Using the gettimeofday() system call, measure and 
plot the following two graphs.
<ul>
	<li>
		Total execution time for the parent process versus number of processes P.
	</li>
	<li>
		The average time to acquire the lock in each child process versus the number of processes P
	</li>
</ul>
<p> Explain the results you obtain in a PDF report that you must include with your submission.

 
<H2>Grading Guidelines</H2> 
<pre> 
	Part A: Multi-Process Addition without locking - 20
		Creation and execution of processes 
		Creation and use of shared memory data region 
 
	Part B: Multi-process Addition with Locking - 50
		Proper semaphore initialization.
		Correct use of locking/unlocking so that only one process is in the critical section at a time 
		Busy-wait locking with "sem_trywait()" and "continue" 
		Busy-wait locking with "sem_trywait()" and "sched_yield()" 
		Busy-wait locking with "sem_wait()" 
 
	Part C: Comparing the Game of Turns - 25
		Correct implementation and collection of profiling statistics 
		Final PDF report with profiling results, graphs and explanations 
 
	Error Handling, README, Makefile and Coding style - 5
		Cleanup of shared memory region, checking for return values/error conditions, etc.
 
	Total = 100
</pre> 
 
<H2>Submission Guidelines</H2> 
<p> Submit all your code and your PDF report as ONE zipped file. Name your directory as "your_username/" and the name the zip file as "your_username.zip". Replace "your_username" with your BU login username (don't use your B number).
 
</body> 
 
</html> 
