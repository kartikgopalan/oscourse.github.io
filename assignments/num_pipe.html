<H1> Named Pipe for Exchanging Lines </H1>


<H2>Objective</H2>
You will implement a kernel-level pipe for exchanging numbers among user-level processes.
You will learn about concurrency, synchronization, and various kernel primitives.
You may find the following resources helpful in addition to any other online resources.
<ul>
<li> <a href=http://tldp.org/LDP/lkmpg/2.4/html/index.html>Linux kernel module programming</a>
<li> <a href=https://www.linuxjournal.com/article/2920>Miscellaneous Character Devices</a>
<li><a href=slides/semaphores_waitqs_kernel_api.pdf>Kernel API for Semaphores and Waitqueues</a>
<li> <a href=http://free-electrons.com/doc/books/ldd3.pdf> Linux Device Drivers book </a>
</ul>


<a name=taska></a>
<H2>Task A - Learn kernel modules, character devices, and named pipes</H2>
<ol>
<li> Learn how to create kernel modules from chapters 1, 2, and 3 of <a href=http://tldp.org/LDP/lkmpg/2.4/html/index.html>Linux kernel module programming</a> website.
<li> Try the <a href=https://oscourse.github.io/examples/module/>Example module code</a> and understand how it works.
<li> Learn how to write a <i>character device kernel module</i> from Chapter 4 of <a href=http://tldp.org/LDP/lkmpg/2.4/html/x579.html>Linux kernel module programming</a> website.
<li> Learn what is a <i>named pipe</i> in UNIX.
<li> Figure out how to create and use a named pipe using command line in Linux using the <tt>mkfifo</tt> command.
</ol>

<a name=taskb></a>
<H2> Task B - Study userspace producer consumer programs.</H2>
<ol>
<li> Read, understand, and run, following two user-level C-programs for a consumer and a producer.
<ul>
	<li> <a href=assignments/consumer_numbers.c>Consumer C program</a> 
	<li> <a href=assignments/producer_numbers.c>Producer C program</a> 
</ul>
<li> Run one consumer and one producer concurrently. To do this, open two text terminals. Run a consumer in one and a producer in another at the same time.)
<ul>
	<li> Kill the producer with Ctrl-C. Leave consumer running.  What happens and why?
	<li> Kill the consumer with Ctrl-C. Leave producer running.  What happens and why?
</ul>
<li> Run one consumer and multiple producers concurrently. 
<li> Run multiple consumers and one producer concurrently. 
<li> Run multiple consumers and multiple producers concurrently. 
<li> Note down what you observe, and why, in your README file. Do you see any race conditions? If not, can you reason about what could go wrong?
<li> Learn the <a href=slides/semaphores_waitqs_kernel_api.pdf>Kernel API for Semaphores and Waitqueues</a>.
</ol>

<a name=taskc></a>
<H2> Task C - Creating a Number Pipe</H2>
Replace the UNIX named pipe in the producer and consumer scripts from Task B with 
your own implementation of a <a href=http://tldp.org/LDP/lkmpg/2.4/html/x579.html>character device</a> (say /dev/numpipe)
as a kernel module in Linux. (You can also implement a <a href=https://www.linuxjournal.com/article/2920>miscellaneous character device</a> for this part, instead of a regular character device.)
This device must maintain a FIFO queue (i.e. a pipe) of maximum N numbers. N must be given as a module parameter during the insmod command.
<ul>
<li> Producers write numbers to /dev/numpipe.
<li> Consumers read numbers from /dev/numpipe and print it on the screen.
<li> When the pipe is full, i.e. when there are N numbers are stored in /dev/numpipe, then any producer trying to write will block.
<li> When the pipe is empty, i.e. when there are no numbers in /dev/numpipe, then any consumer trying to read will block.
<li> When a consumer reads from a full pipe, it wakes up all blocked producers. In this case, no blocked consumer should be woken up.
<li> When a producer writes to an empty pipe, it wakes up all blocked consumers. In this case, no blocked producer should be woken up.
<li> No deadlocks. All producers and consumers make progress as long as at least one of each is running.
<li> No race conditions. Each number that is written by producers is read EXACTLY once by one consumer. No number is lost. No number is read more than once. 
</ul>


<a name=tolearn></a>
<H2>What you need to learn to complete this assignment</h2>
You can use either the semaphore-version of the solution to producer-consumer problem or a monitor-type solution, both of which were covered in class.
The semaphore version may be easier to implement. You will need to learn the following kernel mechanisms.
<ul>
<li>Using semaphores in kernel using the following functions: sema_init(), DEFINE_SEMAPHORE, down_interruptible() (preferred over down()), and up().
<li>For alternative implementations using mutexes and waitqs: mutex_init(), DEFINE_MUTEX, mutex_lock(), mutex_unlock(), init_wait_queue_head(), wait_event_interruptible() (preferred over wait_event), and wake_up_interruptible() (or wake_up).
<li>Memory allocation in kernel using kmalloc() or kzalloc().
</ul>

<a name=faq></a>
<H2> Frequently asked questions </H2>
<P>
Q: Is there any locking in user space for Part C? 
<br>
A: No, all synchronization happens in kernel space.

<P>
Q: Do we implement our own producers and consumers in user space?
<br>
A: No, use the two C programs given above. 

<p>
Q: How to I terminate producers and consumers?
<br>
A: After fixed number of iterations OR using Ctrl-C.

<p> 
Q: Why should I use *_interruptible versions of kernel functions?
<br>
A: So that your producer/consumer code can be terminated using Ctrl-C in user space. We'll test for this during demo.

<p>
Q: How does the producer generate a unique number? 
<br>
A: Please see C programs above. 

<p>
Q: How to I run multiple producers and consumers concurrently?
<br>
A: Open multiple terminals. Run one consumer or producer in the foreground each terminal. 

<a name=gg></a>
<H2>Grading Guidelines</h2>
<ul>
	<li> Parts A and B : 30
	<li> Part C: 70
		<ul>
		<li> Code works for one producer and one consumer.
		<li> Code works for multiple concurrent producers and consumers. 
		<li> No deadlocks. All producers and consumers make progress as long as at least one of each is running.
		<li> No race conditions. Each number is read EXACTLY once by one consumer. No number is lost. No number is read more than once. 
		<li> Producers block  on write when pipe is full.
		<li> Consumers block on read when pipe is empty.
		<li> Blocked producers are not woken up by other producers. Blocked consumers are not woken up by other consumers.
		<li> Blocked producers and consumers can be terminated cleanly using Ctrl-C
		<li> Handle all major error conditions.
		</ul>
</ul>

