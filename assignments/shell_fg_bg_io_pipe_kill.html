<html> 
<head> 
  <title>Mini Shell</title> 
</head> 
<body> 

<h1>Assignment: Mini Shell</h1>

<h2> Part A</h2>

<p>This assignment helps you learn about 
processes and basic process management in a shell.
You are asked to write a simple shell program called <tt>minish</tt>.
This shell must work as follows. When you start your mini shell,
it prints the following prompt and waits for a command from user.
<pre>
minish>
</pre>

From here onwards, you should be able to execute and control 
<b>any binary executable</b> just as you would in a normal shell. 
For instance 

<pre>
minish> Command

[ OUTPUT OF COMMAND SHOWN HERE ]

minish>
</pre>

<p>
Additionally, your shell should be able to do the following: 
</p>

<ol> 

	<li>
		Execute commands with multiple arguments. For example:
		<pre>
		minish> Command arg1 arg2 arg3
		</pre>
	</li>

	<li>
		Execute commands in either foreground or background mode. In foreground mode, the shell just waits for the command to complete before displaying the shell prompt again (as in the above example). For background mode, a command (say Command 1) is executed with an ampersand <tt>&</tt> suffix. The shell prints the process ID of the backgrounded process and immediately prints the prompt to accept and execute the next command (say Command2), even as Command1 continues executing in the background. For example:
		<pre>
		minish> Command1 &
		Process print_process_id_1_here in background mode
		minish> Command2

		[OUTPUT OF Command1 AND Command2 MAY INTERLEAVE IN ARBITRARY ORDER]
		</pre>
	</li>

	<li>
		Maintain multiple processes running in background mode simultaneously. For example:
		<pre>
		minish> Command1 &
		Process print_process_id_1_here in background mode
		minish> Command2 &
		Process print_process_id_2_here in background mode
		minish> Command3 &
		Process print_process_id_3_here in background mode
		minish> 

		[OUTPUT OF Command1, Command2, AND Command3 MAY INTERLEAVE IN ARBITRARY ORDER]

		</pre>
	</li>

	<li>	
		Redirect the input of a command from a file. For example:
		<pre>
		minish> Command < input_file
		</pre>
		Redirect the output of a command to a file. For example:
		<pre>
		minish> Command > output_file
		</pre>
	</li>

<h2> Part B</h2>

	<li>
		Implement command filters, i.e., redirect the stdout of one command to stdin of another using pipes. For example:
		<pre>
		minish> ls -l | wc -l
		</pre>
		<pre>
		minish> cat somefile | grep somestring | less
		</pre>

		Ideally, your shell should be able to handle any number of filter components.
	</li>

	<li>
		Terminate a foreground process by pressing <tt>[Ctrl-C]</tt>.  Your shell must not get killed; only the process running in foreground mode must terminate. If executing a chain of filters (as in the above example), all processes in the filter chain must terminate.
	</li>

<!--
	<li>
		Temporarily stop a process using <tt>[Ctrl-Z]</tt>.  Your shell must not stop; only the process running inside your shell must stop.  Your shell must be able to hold multiple processes in stopped state. 
	</li>

-->
	<li> Kill a process in background using the <tt>kill</tt> command. 
		<pre>
		minish> kill give_process_id_here
		</pre>
	</li>

<!--
	<li>
		Any signal should be delivered to the entire process-group of the immediate child process, not just to the immediate child process. For example, if mysh starts process A and process A forks another process B, then any signal should be delivered to both process A and process B. How will you do this? For this you need to understand the notion of a process group. Check out the man pages for <tt>setsid()</tt> and <tt>killpg()</tt>.
	</li>

	<li> 
		Bring a backgrounded process to foreground using the <tt>fg</tt>  directive.  The <tt>fg</tt> directive must be able to bring any stopped/backgrounded process to foreground using the <tt>%N</tt> argument.
	</li>
-->

	<li>
		Be able to execute any feasible combinations of filters and file I/O redirection.
	</li>

	<li>
		The <tt>exit</tt>  command should terminate your shell.  Clean up any orphan processes as your shell exits.
	</li>

<!--
	<li>
		The <tt>cd</tt> command must actually change the directory of your shell  and the <tt>pwd</tt> command must return the current directory of your shell. Note that normal <tt>fork-exec</tt> mechanism won't work here. Why?
	</li>
-->

</ol>


<a name=donots>
<h2>Do Nots:</h2>
</a>
<ul> 
	<li>
		DO NOT use any special wrapper libraries or classes to borrow the basic functionality required in this assignment. If in doubt, ask the instructor first BEFORE doing so.
	</li> 
	<li>
		DO NOT use the <b>system(...) </b> syscall to execute the programs in your shell directly.
	</li> 
	<li> 
		DO NOT write five or six different programs, one for each feature. Write <b>one single program</b> that includes all the above features. 
	</li> 

	<li>
		You do not need to implement any scripting functionalities.
	</li>

	<li>
		You do not need to implement wild character expansions such as *,?,[0-9], etc.
	</li>
</ul> 

<a name=hints>
<h2>Hints:</h2> 
</a>

<ul> 
  <li>Build  and test one featur at a time. </li> 
  <li>Use Github to save and track changes to your code. Make backup copies of partially working versions of your code. This way, if you irreparably mess up your code, then you can at least roll back to your last backup copy. </li> 
  <li>First design your data structures and code-structure before you begin coding each feature. Anticipate specific problems you will face. </li> 
  <li>Check out man page for the following, which might be useful:
    <ul> 
	<li>fork()</li>
	<li>execv() and execl() (which one should you use?)</li>
	<li>waitpid()</li> 
	<li>dup2() (for stdin/stdout redirection) </li>
	<li>pipe()</li> 
	<li>open()</li> 
	<li>close()</li> 
	<li>fileno()</li> 
	<li> kill()</li> 
<!--
	<li> chdir()</li> 
	<li> getcwd()</li> 
-->
	<li>killpg()</li> 
	<li>setsid()</li> 
	<li>getgrp()</li> 
	<li>getpgid()</li> 
	<li>tcsetpgrp()</li> 
    </ul> 
  </li> 
<!--
  <li>Know the difference between <b>SIGSTOP </b>and <b>SIGTSTP</b> and which one to use?</li> 
-->
</ul>

<a name=gg>
<h2> Grading Guidelines </h2>
</a>

<pre>
	This is how we will grade your assignment during the demo. So please prioritize your work accordingly.

	 5 - README, Makefile, Compilation without errors

         5 - Executing a command with no arguments in foreground

         5 - Executing a command with multiple arguments in foreground

         5 - Executing a single command in background

        10 - Executing multiple commands in background simultaneously

        10 - Input redirection from file: Executing a single command that takes standard input (stdin) from a file

        10 - Output redirection to file: Executing a single command that sends standard output (stdout) to a file

        10 - Terminating a foreground process using Ctrl+C without killing the shell

        10 - Terminate a background process using kill command

        30 - Filters
                10 - Be able to execute filter chain with two components
                20 - Be able to execute filter chain of arbitrary length

        20 - Combinations
                10 - Executing a filter chain while redirecting input of the first command and/or output of the last command
                10 - Terminating a chain of filters

        10 - Error Handling
                For example, you should handle all errors returned by ALL systems calls used in your
                program. Also check for other common error conditions in your program.
                But don't go overboard with error checking.
                We will not try to intentionally break your code with bad
                input that may be irrelevant to the assignment's goals.

        Total = 130

</pre>

<!--
        10 - Temporarily stopping the processes using Ctrl+Z
        10 - Implementation of cd and pwd command
        10 - Implementation of fg directive to bring background/stopped process to foreground
                10 - Executing a background command with redirected stdin/stdout
                10 - Executing a chain of pipes in the background
-->



<br>
<br</ul> 
</body> 
</html> 
